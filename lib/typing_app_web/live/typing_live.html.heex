<div class="game-container" phx-hook=".SoundSystem" id="sound-system">
  <!-- Sound Controls -->
  <div class="sound-controls">
    <button class="sound-btn" phx-click="toggle_sound">
      <%= if @sound_enabled, do: "🔊", else: "🔇" %>
    </button>
  </div>

  <div class="header">
    <h1 class="title">🎮 TypeMaster Kids 🎮</h1>
  </div>

  <%= if @game_state == :waiting do %>
    <div class="level-info">
      <div>
        <strong>Level: <%= @current_level %></strong>
        <div><%= level_description(@current_level) %></div>
      </div>
      <div>
        <strong>Score: <%= @score %></strong>
        <div>Total: <%= @progress.total_score %></div>
      </div>
      <div>
        <strong>Best WPM: <%= Float.round(@progress.best_wpm, 1) %></strong>
        <div>Keep improving!</div>
      </div>
    </div>

    <div class="text-display">
      Ready to start level <%= @current_level %>? Click the button below!
    </div>


    <div class="controls">
      <button class="btn btn-primary" phx-click="start_game" phx-key-action="start_game" phx-hook=".AutoFocusButton" autofocus id="start-button">🚀 Start Level <%= @current_level %></button>
      <button class="btn btn-warning" phx-click="reset_game">🔄 Reset Progress</button>
    </div>

  <% else %>
    <!-- Game playing interface with all the existing content -->
    <div class="level-info">
      <div>
        <strong>Level: <%= @current_level %></strong>
        <div><%= level_description(@current_level) %></div>
      </div>
      <div>
        <strong>Score: <%= @score %></strong>
        <div>Keep typing!</div>
      </div>
      <div>
        <strong>Lives: <%= String.duplicate("💚️", @lives) %></strong>
        <div><%= lives_message(@lives) %></div>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" style={"width: #{progress_percentage(@current_index, @current_text)}%"}></div>
    </div>

    <div class="text-display">
      <div class="typing-progress">
        <div class="progress-percentage">
          <%= progress_percentage(@current_index, @current_text) %>% Complete
        </div>
      </div>
      <div class="text-content">
        <%= for {char, index} <- String.graphemes(@current_text) |> Enum.with_index() do %>
          <span class={"char #{char_class(index, @current_index, @typed_text, @current_text)}"}>
            <%= if char == " ", do: raw("&nbsp;"), else: char %>
          </span>
        <% end %>
      </div>
    </div>
  <% end %>

  <!-- Hidden data for JavaScript sound system -->
  <div id="sound-data"
       data-sound-enabled={to_string(@sound_enabled)}
       data-typing-sound-enabled={to_string(@typing_sound_enabled)}
       data-background-music-enabled={to_string(@background_music_enabled)}
       data-last-sound-event={@last_sound_event}
       data-current-index={@current_index}
       data-key-pressed={@current_index > 0 && String.at(@current_text, @current_index-1) == String.at(@typed_text, @current_index-1)}
       style="display: none;">
  </div>

  <!-- Hidden element for game state detection -->
  <div class="game-state" data-state={@game_state} style="display: none;">
  </div>

  <%= if @game_state == :playing do %>
      <div class="input-area">
        <input
          type="text"
          class="typing-input"
          value={@typed_text}
          phx-keyup="key_typed"
          phx-update="ignore"
          phx-hook=".TypeFocusSync"
          placeholder="Start typing here..."
          autocomplete="off"
          spellcheck="false"
          autofocus
          id="typing-input"
        />
      </div>
    <% end %>

    <div class="stats">
      <div class="stat">
        <div class="stat-value"><%= Float.round(@wpm, 1) %></div>
        <div class="stat-label">Words/Min</div>
      </div>
      <div class="stat">
        <div class="stat-value"><%= Float.round(@accuracy, 1) %>%</div>
        <div class="stat-label">Accuracy</div>
      </div>
      <div class="stat">
        <div class="stat-value"><%= @time_left %></div>
        <div class="stat-label">Time Left</div>
      </div>
      <div class="stat">
        <div class="stat-value"><%= @streak %></div>
        <div class="stat-label">Streak</div>
      </div>
    </div>

    <%= if @game_state == :level_complete do %>
      <div class="game-complete">
        <h2>🎉 Level <%= @current_level %> Complete! 🎉</h2>
        <p class="emoji">🌟⭐🌟⭐🌟</p>
        <p>Final Score: <%= @score %></p>
        <p>WPM: <%= Float.round(@wpm, 1) %> | Accuracy: <%= Float.round(@accuracy, 1) %>%</p>

        <!-- Guest user sign-up prompt -->
        <%= unless @current_scope && @current_scope.user do %>
          <div class="guest-prompt" style="margin: 15px 0; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 10px; border: 2px dashed #fff;">
            <h3>Playing as Guest</h3>
            <p>Your progress won't be saved. Sign up to:</p>
            <ul style="text-align: left; display: inline-block;">
              <li>Save your progress</li>
              <li>Track your improvement</li>
              <li>Compete on leaderboards</li>
            </ul>
            <div>
              <a href="/users/register" class="btn btn-secondary">Sign Up</a>
              <a href="/users/log-in" class="btn btn-secondary">Log In</a>
            </div>
          </div>
        <% end %>

        <div class="controls" style="margin-top: 20px;">
          <%= if @current_level < 5 do %>
            <button class="btn btn-primary" phx-click="next_level">⬆️ Next Level</button>
          <% else %>
            <div>🏆 Congratulations! You've mastered all levels! 🏆</div>
            <button class="btn btn-primary" phx-click="reset_game" autofocus phx-hook=".AutoFocusButton" id="try-again-button" data-key-action="reset_game">🔄 Play Again</button>
          <% end %>
        </div>
      </div>
    <% end %>

    <%= if @game_state == :game_over do %>
      <div class="game-over">
        <h2>💪 Keep Practicing! 💪</h2>
        <p>Don't worry - every expert was once a beginner!</p>
        <button
          class="btn btn-primary"
          phx-click="start_game"
          autofocus
          phx-hook=".AutoFocusButton"
          id="try-again-button"
          data-key-action="start_game"
        >🔄 Try Again</button>
        <button class="btn btn-secondary" phx-click="reset_game">🏠 Back to Level 1</button>
        <p class="help-text">Press <kbd>Enter</kbd> to try again</p>
      </div>
    <% end %>

    <!-- Text Source Selector - Always visible at the bottom -->
    <div class="text-source-selector fixed-bottom">
      <div class="source-label">Select Text Source:</div>
      <div class="source-buttons">
        <%= for {source_key, source_name} <- @text_sources do %>
          <button
            type="button"
            phx-click="select_text_source"
            phx-value-source={source_key}
            class={"source-btn #{if @selected_source == source_key, do: 'selected'}"}
          >
            <%= source_name %>
          </button>
        <% end %>
      </div>
      <div class="source-info">
        <%= case @selected_source do %>
          <% :zenquotes -> %>
            Using <a href="https://zenquotes.io/" target="_blank">ZenQuotes API</a> - inspirational quotes
          <% :dummyjson -> %>
            Using <a href="https://dummyjson.com/docs/quotes" target="_blank">DummyJSON API</a> - sample quotes
          <% _ -> %>
            Using built-in text samples for each level
        <% end %>
      </div>
    </div>
</div>

<script :type={Phoenix.LiveView.ColocatedHook} name=".SoundSystem">
    export default {
      mounted() {
        this.initSoundSystem()
        this.lastSoundEvent = null
        this.soundEnabled = true
        this.typingSoundEnabled = true
        this.backgroundMusicEnabled = false
        this.backgroundMusicPlaying = false
        this.backgroundMusicAudio = null

        // Initialize music library for better UX when user enables music
        setTimeout(() => {
          this.initBackgroundMusic()
        }, 2000) // Delay by 2s to not interfere with initial page load
        
        // Listen for updates from LiveView
        this.handleEvent = (event, payload) => {
          // Handle any custom events if needed
        }
      },

      updated() {
        // Check for sound events when component updates
        const soundData = document.getElementById('sound-data')
        if (soundData) {
          const soundEnabled = soundData.dataset.soundEnabled === "true"
          const typingSoundEnabled = soundData.dataset.typingSoundEnabled === "true"
          const backgroundMusicEnabled = soundData.dataset.backgroundMusicEnabled === "true"
          const lastSoundEvent = soundData.dataset.lastSoundEvent
          const keyPressed = soundData.hasAttribute('data-key-pressed')
          const gameState = document.querySelector('.game-state')?.dataset?.state || ''

          this.soundEnabled = soundEnabled
          this.typingSoundEnabled = typingSoundEnabled
          const wasBackgroundMusicEnabled = this.backgroundMusicEnabled
          this.backgroundMusicEnabled = backgroundMusicEnabled

          // Handle background music toggling
          if (backgroundMusicEnabled !== wasBackgroundMusicEnabled) {
            if (backgroundMusicEnabled && soundEnabled) {
              this.startBackgroundMusic()
            } else {
              this.stopBackgroundMusic()
            }
          }

          // Start/stop background music based on game state
          const isPlaying = gameState === 'playing' || document.querySelector('.game-complete')
          if (this.backgroundMusicEnabled && soundEnabled && isPlaying && !this.backgroundMusicPlaying) {
            this.startBackgroundMusic()
          } else if ((!this.backgroundMusicEnabled || !soundEnabled || !isPlaying) && this.backgroundMusicPlaying) {
            this.stopBackgroundMusic()
          }

          // Track if we've played a keystroke sound to avoid duplicate sounds
          const currentIndex = parseInt(soundData.dataset.currentIndex || '0')
          if (this.lastIndex !== currentIndex) {
            this.lastIndex = currentIndex
            this.keyStrokePlayed = false
          }

          // Play keystroke sound when typing correctly
          if (keyPressed && this.typingSoundEnabled && this.soundEnabled && !this.keyStrokePlayed) {
            this.playKeySound()
            this.keyStrokePlayed = true
          }

          // Play other sound events
          if (lastSoundEvent && lastSoundEvent !== this.lastSoundEvent && this.soundEnabled) {
            console.log('Playing sound', lastSoundEvent)
            this.playSound(lastSoundEvent)
            this.lastSoundEvent = lastSoundEvent
          }
        }
      },

      initSoundSystem() {
        try {
          console.log('Web Audio API supported')
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)()
        } catch (e) {
          console.log('Web Audio API not supported')
        }
      },

      resumeContext() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
          this.audioContext.resume()
        }
      },

      initBackgroundMusic() {
        // Skip initialization if already done
        if (this.musicInitialized) return;
        
        // No external files needed - entirely Web Audio API based
        console.log('Initializing WebAudio music library...');
        
        // Create music library with different styles
        this.musicLibrary = [
          this.createAmbienceTrack,
          this.createLofiTrack,
          this.createPianoTrack,
          this.createMeditationTrack,
          this.createCalmTrack
        ];
        
        this.musicInitialized = true;
        console.log('Web Audio music library initialized with 5 tracks');
      },
      
      // Track 1: Ambient Atmosphere
      createAmbienceTrack() {
        if (!this.audioContext) return null;
        this.resumeContext();
        
        const master = this.audioContext.createGain();
        master.gain.value = 0.15;
        master.connect(this.audioContext.destination);
        
        // Create pad sounds
        const createPad = (baseFreq, detune) => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const filter = this.audioContext.createBiquadFilter();
          
          osc.type = 'sine';
          osc.frequency.value = baseFreq;
          osc.detune.value = detune;
          
          filter.type = 'lowpass';
          filter.frequency.value = 1000;
          filter.Q.value = 1.5;
          
          gain.gain.value = 0.1;
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(master);
          
          osc.start();
          return { oscillator: osc, gain: gain, filter: filter };
        };
        
        // Create ambient pad chord (Fm9)
        const pads = [
          createPad(174.61, 0),     // F3
          createPad(349.23, 5),     // F4
          createPad(415.30, -5),    // Ab4
          createPad(523.25, 0),     // C5
          createPad(587.33, 4)      // D5
        ];
        
        // Add slow LFO for movement
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.05;
        lfoGain.gain.value = 100;
        
        lfo.connect(lfoGain);
        pads.forEach(pad => lfoGain.connect(pad.filter.frequency));
        
        lfo.start();
        
        return {
          pads: pads,
          lfo: lfo,
          master: master,
          name: 'Ambient Atmosphere'
        };
      },
      
      // Track 2: Lofi Style
      createLofiTrack() {
        if (!this.audioContext) return null;
        this.resumeContext();
        
        const master = this.audioContext.createGain();
        master.gain.value = 0.25;
        master.connect(this.audioContext.destination);
        
        // Lofi chord progression using simple tones
        const createNote = (freq, time, duration, type = 'triangle') => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const filter = this.audioContext.createBiquadFilter();
          
          osc.type = type;
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 1200;
          
          gain.gain.value = 0.0;
          gain.gain.setValueAtTime(0.0, this.audioContext.currentTime + time);
          gain.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + time + 0.02);
          gain.gain.setValueAtTime(0.1, this.audioContext.currentTime + time + duration - 0.05);
          gain.gain.linearRampToValueAtTime(0.0, this.audioContext.currentTime + time + duration);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(master);
          
          osc.start();
          osc.stop(this.audioContext.currentTime + time + duration + 0.1);
          
          return { oscillator: osc, gain: gain };
        };
        
        // Lofi pattern
        const loopLength = 4; // 4 seconds per loop
        const scheduleLoop = () => {
          // Cmaj7 chord
          createNote(261.63, 0, 0.8);       // C4
          createNote(329.63, 0, 0.8);       // E4
          createNote(392.00, 0, 0.8);       // G4
          createNote(493.88, 0, 0.8);       // B4
          
          // Am7 chord
          createNote(220.00, 1, 0.8);       // A3
          createNote(261.63, 1, 0.8);       // C4
          createNote(329.63, 1, 0.8);       // E4
          createNote(392.00, 1, 0.8);       // G4
          
          // Fmaj7 chord
          createNote(174.61, 2, 0.8);       // F3
          createNote(220.00, 2, 0.8);       // A3
          createNote(261.63, 2, 0.8);       // C4
          createNote(349.23, 2, 0.8);       // F4
          
          // G7 chord
          createNote(196.00, 3, 0.8);       // G3
          createNote(246.94, 3, 0.8);       // B3
          createNote(293.66, 3, 0.8);       // D4
          createNote(349.23, 3, 0.8);       // F4
          
          // Schedule next loop
          this.loopTimer = setTimeout(scheduleLoop, loopLength * 1000);
        };
        
        // Start the loop
        scheduleLoop();
        
        return {
          master: master,
          stopLoop: () => {
            if (this.loopTimer) {
              clearTimeout(this.loopTimer);
              this.loopTimer = null;
            }
          },
          name: 'Lofi Beats'
        };
      },
      
      // Track 3: Piano Meditation
      createPianoTrack() {
        if (!this.audioContext) return null;
        this.resumeContext();
        
        const master = this.audioContext.createGain();
        master.gain.value = 0.2;
        master.connect(this.audioContext.destination);
        
        // Piano-like sound
        const createPianoNote = (freq, startTime, length) => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          // Piano-like envelope
          gain.gain.setValueAtTime(0, this.audioContext.currentTime + startTime);
          gain.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + startTime + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + startTime + length);
          
          osc.connect(gain);
          gain.connect(master);
          
          osc.start(this.audioContext.currentTime + startTime);
          osc.stop(this.audioContext.currentTime + startTime + length + 0.1);
          
          return { oscillator: osc, gain: gain };
        };
        
        // Gentle piano arpeggio in A minor
        const playArpeggio = () => {
          createPianoNote(220.00, 0.0, 1.5);  // A3
          createPianoNote(261.63, 0.5, 1.5);  // C4
          createPianoNote(329.63, 1.0, 1.5);  // E4
          createPianoNote(440.00, 1.5, 1.5);  // A4
          createPianoNote(523.25, 2.0, 1.5);  // C5
          createPianoNote(659.26, 2.5, 1.5);  // E5
          createPianoNote(440.00, 3.0, 1.5);  // A4
          createPianoNote(329.63, 3.5, 1.5);  // E4
          
          // Schedule next arpeggio
          this.pianoTimer = setTimeout(playArpeggio, 4000);
        };
        
        // Start the piano sequence
        playArpeggio();
        
        return {
          master: master,
          stopPiano: () => {
            if (this.pianoTimer) {
              clearTimeout(this.pianoTimer);
              this.pianoTimer = null;
            }
          },
          name: 'Piano Meditation'
        };
      },
      
      // Track 4: Deep Meditation
      createMeditationTrack() {
        if (!this.audioContext) return null;
        this.resumeContext();
        
        const master = this.audioContext.createGain();
        master.gain.value = 0.15;
        master.connect(this.audioContext.destination);
        
        // Drone synths
        const createDrone = (freq, type = 'sine') => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const filter = this.audioContext.createBiquadFilter();
          
          osc.type = type;
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 800;
          
          gain.gain.value = 0.1;
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(master);
          
          osc.start();
          
          return { oscillator: osc, gain: gain, filter: filter };
        };
        
        // Create drones in perfect fifths for meditation
        const drones = [
          createDrone(110),    // A2
          createDrone(164.81), // E3
          createDrone(220),    // A3
          createDrone(293.66)  // D4
        ];
        
        // Add very slow LFO for subtle movement
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        
        lfo.type = 'triangle';
        lfo.frequency.value = 0.03;
        lfoGain.gain.value = 100;
        
        lfo.connect(lfoGain);
        drones.forEach(drone => {
          lfoGain.connect(drone.filter.frequency);
        });
        
        lfo.start();
        
        return {
          drones: drones,
          lfo: lfo,
          master: master,
          name: 'Deep Meditation'
        };
      },
      
      // Track 5: Calm Vibes
      createCalmTrack() {
        if (!this.audioContext) return null;
        this.resumeContext();
        
        const master = this.audioContext.createGain();
        master.gain.value = 0.15;
        master.connect(this.audioContext.destination);
        
        // Mellow synth pad
        const createMellowPad = (frequency, detune = 0) => {
          const oscillator1 = this.audioContext.createOscillator();
          const oscillator2 = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          const filter = this.audioContext.createBiquadFilter();
          
          oscillator1.type = 'sine';
          oscillator1.frequency.value = frequency;
          oscillator1.detune.value = detune;
          
          oscillator2.type = 'triangle';
          oscillator2.frequency.value = frequency * 2;
          oscillator2.detune.value = detune - 5;
          
          filter.type = 'lowpass';
          filter.frequency.value = 1000;
          filter.Q.value = 0.8;
          
          gainNode.gain.value = 0.08;
          
          oscillator1.connect(filter);
          oscillator2.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(master);
          
          oscillator1.start();
          oscillator2.start();
          
          return { oscillators: [oscillator1, oscillator2], gain: gainNode, filter: filter };
        };
        
        // Create Gmaj9 chord (G, B, D, F#, A)
        const pads = [
          createMellowPad(196.00, 0),   // G3
          createMellowPad(246.94, 4),   // B3
          createMellowPad(293.66, -4),  // D4
          createMellowPad(370.00, 0),   // F#4
          createMellowPad(440.00, 3)    // A4
        ];
        
        return {
          pads: pads,
          master: master,
          name: 'Calm Vibes'
        };
      },
      
      startBackgroundMusic() {
        if (!this.soundEnabled || !this.backgroundMusicEnabled || this.backgroundMusicPlaying) return;

        // Initialize music library if not already done
        if (!this.musicInitialized) {
          this.initBackgroundMusic();
        }
        
        try {
          // Make sure Web Audio API is available
          if (!this.audioContext) {
            console.error('Web Audio API not available');
            return;
          }

          // Select a random track from our library
          const trackIndex = Math.floor(Math.random() * this.musicLibrary.length);
          const createTrackFunction = this.musicLibrary[trackIndex];
          
          // Create the selected track
          this.currentMusicTrack = createTrackFunction.call(this);
          
          if (this.currentMusicTrack) {
            console.log(`Playing background music: ${this.currentMusicTrack.name}`);
            this.backgroundMusicPlaying = true;
          } else {
            console.error('Failed to create music track');
          }
          
        } catch (error) {
          console.error('Error starting background music:', error);
          this.tryFallbackAudio(); // Use the simplest fallback as a last resort
        }
      },

      stopBackgroundMusic() {
        this.backgroundMusicPlaying = false;
        
        // Stop the current music track if it exists
        if (this.currentMusicTrack) {
          try {
            // Handle different types of tracks
            
            // Stop Lofi track (needs to clear timeout)
            if (this.currentMusicTrack.stopLoop) {
              this.currentMusicTrack.stopLoop();
            }
            
            // Stop Piano track (needs to clear timeout)
            if (this.currentMusicTrack.stopPiano) {
              this.currentMusicTrack.stopPiano();
            }
            
            // Stop oscillators in ambient/pad tracks
            if (this.currentMusicTrack.pads) {
              this.currentMusicTrack.pads.forEach(pad => {
                if (pad.oscillator) {
                  pad.oscillator.stop();
                }
                if (pad.oscillators) {
                  pad.oscillators.forEach(osc => osc.stop());
                }
              });
            }
            
            // Stop drones in meditation track
            if (this.currentMusicTrack.drones) {
              this.currentMusicTrack.drones.forEach(drone => {
                drone.oscillator.stop();
              });
            }
            
            // Stop LFO if it exists
            if (this.currentMusicTrack.lfo) {
              this.currentMusicTrack.lfo.stop();
            }
            
            console.log(`Stopped ${this.currentMusicTrack.name} music`);
            this.currentMusicTrack = null;
          } catch (e) {
            console.error('Error stopping background music:', e);
          }
        }

        // Stop fallback oscillators if they exist
        if (this.fallbackOscillators) {
          try {
            if (this.fallbackOscillators.chord) {
              // Stop all chord oscillators from enhanced music
              this.fallbackOscillators.chord.forEach(note => {
                note.oscillator.stop();
              });
              
              // Stop LFO for rhythm
              if (this.fallbackOscillators.lfo) {
                this.fallbackOscillators.lfo.stop();
              }
              
              console.log('Stopped enhanced fallback ambient music');
            } else if (this.fallbackOscillators.mainOscillator) {
              // Handle legacy structure (for backward compatibility)
              this.fallbackOscillators.mainOscillator.stop();
              this.fallbackOscillators.modulationOscillator.stop();
              console.log('Stopped basic fallback audio');
            }
            
            this.fallbackOscillators = null;
          } catch (e) {
            console.error('Failed to stop fallback oscillators:', e);
          }
        }
      },
      
      tryFallbackAudio() {
        console.log('Starting enhanced fallback music')
        this.backgroundMusicPlaying = false
        
        // Create a more complex ambient music using Web Audio API
        try {
          if (this.audioContext) {
            // Only attempt if Web Audio API is available
            this.resumeContext()
            
            // Create our main audio components
            const masterGain = this.audioContext.createGain()
            masterGain.gain.value = 0.15 // Master volume
            masterGain.connect(this.audioContext.destination)
            
            // Create a rich ambient chord with multiple oscillators
            const createChordOscillator = (frequency, type, gainValue) => {
              const osc = this.audioContext.createOscillator()
              const gain = this.audioContext.createGain()
              
              osc.type = type
              osc.frequency.value = frequency
              gain.gain.value = gainValue
              
              osc.connect(gain)
              gain.connect(masterGain)
              
              return { oscillator: osc, gain: gain }
            }
            
            // Create a gentle chord (based on Cmaj7 - C, E, G, B)
            const chord = [
              createChordOscillator(261.63, 'sine', 0.08),  // C4
              createChordOscillator(329.63, 'sine', 0.06),  // E4
              createChordOscillator(392.00, 'sine', 0.04),  // G4
              createChordOscillator(493.88, 'sine', 0.03)   // B4
            ]
            
            // Add some subtle rhythmic elements
            const lfoNode = this.audioContext.createOscillator()
            const lfoGain = this.audioContext.createGain()
            
            lfoNode.frequency.value = 0.07 // Very slow modulation
            lfoGain.gain.value = 0.1       // Subtle effect
            
            lfoNode.connect(lfoGain)
            lfoGain.connect(masterGain.gain)
            
            // Start all audio components
            chord.forEach(note => note.oscillator.start())
            lfoNode.start()
            
            // Store references for stopping later
            this.fallbackOscillators = {
              chord: chord,
              lfo: lfoNode,
              masterGain: masterGain
            }
            
            this.backgroundMusicPlaying = true
            console.log('Enhanced ambient music is now playing')
          }
        } catch (e) {
          console.error('Failed to create fallback audio:', e)
        }
      },

      playKeySound() {
        if (!this.soundEnabled || !this.typingSoundEnabled || !this.audioContext) return

        this.resumeContext()

        const oscillator = this.audioContext.createOscillator()
        const gainNode = this.audioContext.createGain()

        oscillator.connect(gainNode)
        gainNode.connect(this.audioContext.destination)

        // Softer, higher-pitched click for keystrokes
        oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime)
        oscillator.frequency.exponentialRampToValueAtTime(1400, this.audioContext.currentTime + 0.05)
        gainNode.gain.setValueAtTime(0.03, this.audioContext.currentTime)
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05)

        oscillator.start()
        oscillator.stop(this.audioContext.currentTime + 0.05)
      },

      playSound(type) {
        if (!this.soundEnabled || !this.audioContext) return

        this.resumeContext()

        const oscillator = this.audioContext.createOscillator()
        const gainNode = this.audioContext.createGain()

        oscillator.connect(gainNode)
        gainNode.connect(this.audioContext.destination)

        // Different sounds for different events
        switch(type) {
          case 'correct':
            oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime)
            oscillator.frequency.exponentialRampToValueAtTime(1000, this.audioContext.currentTime + 0.1)
            gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime)
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1)
            oscillator.start()
            oscillator.stop(this.audioContext.currentTime + 0.1)
            break

          case 'incorrect':
            oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime)
            oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.2)
            gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime)
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2)
            oscillator.start()
            oscillator.stop(this.audioContext.currentTime + 0.2)
            break

          case 'complete':
            // Play a cheerful completion sound
            const notes = [523, 659, 784, 1047] // C, E, G, C (major chord)
            notes.forEach((freq, index) => {
              const osc = this.audioContext.createOscillator()
              const gain = this.audioContext.createGain()

              osc.connect(gain)
              gain.connect(this.audioContext.destination)

              osc.frequency.setValueAtTime(freq, this.audioContext.currentTime + index * 0.1)
              gain.gain.setValueAtTime(0.1, this.audioContext.currentTime + index * 0.1)
              gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 0.3)

              osc.start(this.audioContext.currentTime + index * 0.1)
              osc.stop(this.audioContext.currentTime + index * 0.1 + 0.3)
            })
            break

          case 'levelup':
            // Ascending scale sound
            const scale = [523, 587, 659, 698, 784, 880, 988, 1047]
            scale.forEach((freq, index) => {
              const osc = this.audioContext.createOscillator()
              const gain = this.audioContext.createGain()

              osc.connect(gain)
              gain.connect(this.audioContext.destination)

              osc.frequency.setValueAtTime(freq, this.audioContext.currentTime + index * 0.08)
              gain.gain.setValueAtTime(0.08, this.audioContext.currentTime + index * 0.08)
              gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.08 + 0.15)

              osc.start(this.audioContext.currentTime + index * 0.08)
              osc.stop(this.audioContext.currentTime + index * 0.08 + 0.15)
            })
            break
        }
      }
    }
</script>

<!-- Auto-focus Hooks -->
<script :type={Phoenix.LiveView.ColocatedHook} name=".AutoFocus">
  export default {
    mounted() {
      // Focus the input element when it's mounted
      this.el.focus()

      // Re-focus when element receives updates
      this.handleEvent("phx:update", () => {
        // Use setTimeout to ensure DOM is fully updated
        setTimeout(() => this.el.focus(), 10)
      })
    },

    updated() {
      // Re-focus the input when it's updated
      this.el.focus()
    }
  }
</script>

<script :type={Phoenix.LiveView.ColocatedHook} name=".TypeFocusSync">
  export default {
    mounted() {
      // Focus the input element when it's mounted
      this.el.focus()

      // Handle value updates from LiveView
      this.handleEvent("sync_input", (payload) => {
        this.el.value = payload.value
      })
    },

    updated() {
      // Keep focus on the input field
      this.el.focus()
    }
  }
</script>

<script :type={Phoenix.LiveView.ColocatedHook} name=".AutoFocusButton">
  export default {
    mounted() {
      // Focus the button when it's mounted
      this.el.focus()

      // Add event listener for the Enter key
      this.handleKeyPress = (event) => {
        if (event.key === 'Enter') {
          // Get the event name from data attribute
          const action = this.el.dataset.keyAction
          if (action) {
            this.pushEvent(action, {})
            event.preventDefault()
          }
        }
      }

      // Add the event listener to the document
      document.addEventListener('keydown', this.handleKeyPress)
    },

    updated() {
      // Re-focus the button when it's updated
      this.el.focus()
    },

    destroyed() {
      // Clean up the event listener when the component is destroyed
      document.removeEventListener('keydown', this.handleKeyPress)
    }
  }
</script>

<!-- CSS Styles -->
<style>
  .game-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    position: relative;
  }

  .sound-controls {
    position: absolute;
    top: 0;
    right: 0;
    background: white;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 1000;
  }

  .sound-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 5px;
    transition: transform 0.2s ease;
  }

  .sound-btn:hover {
    transform: scale(1.1);
  }

  .title {
    text-align: center;
    font-size: 2.5rem;
    color: #4a5568;
    margin-bottom: 30px;
  }

  .level-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
    padding: 15px;
    background: linear-gradient(90deg, #ff9a56 0%, #ff6b95 100%);
    border-radius: 15px;
    color: white;
  }

  .text-display {
    font-size: 1.5rem;
    line-height: 2;
    padding: 20px;
    border: 3px dashed #e2e8f0;
    border-radius: 15px;
    margin-bottom: 20px;
    background: #f8fafc;
    text-align: center;
    min-height: 100px;
    display: flex;
    flex-direction: column;
  }

  .typing-progress {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
  }

  .progress-percentage {
    font-size: 1rem;
    color: #4a5568;
    background: #e2e8f0;
    border-radius: 20px;
    padding: 5px 15px;
    font-weight: bold;
  }

  .text-content {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    padding: 10px;
    border-radius: 10px;
    background: white;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
  }

  .char {
    transition: all 0.2s ease;
    padding: 2px 1px;
    border-radius: 3px;
    font-weight: normal;
    color: #a0aec0; /* Lighter color for untyped text */
    opacity: 0.7;
  }

  .char.correct {
    background: #48bb78;
    color: white;
    font-weight: 700;
    opacity: 1;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    animation: correctBounce 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transform: scale(1.05);
  }

  .char.incorrect {
    background: #f56565;
    color: white;
    font-weight: 700;
    opacity: 1;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    animation: incorrectShake 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  .char.current {
    background: #4299e1;
    color: white;
    font-weight: 700;
    opacity: 1;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    animation: pulse 1s infinite;
    box-shadow: 0 0 8px rgba(66, 153, 225, 0.6);
    position: relative;
  }

  /* Add an underline cursor effect to the current character */
  .char.current::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    width: 100%;
    height: 2px;
    background: white;
    animation: blink 1s infinite;
  }

  @keyframes correctBounce {
    0%, 20%, 60%, 100% { transform: translateY(0); }
    40% { transform: translateY(-10px); }
    80% { transform: translateY(-5px); }
  }

  @keyframes incorrectShake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  .typing-input {
    font-size: 1.2rem;
    padding: 0;
    border: none;
    width: 0;
    height: 0;
    outline: none;
    opacity: 0;
    position: absolute;
    left: -9999px;
  }

  .typing-input:focus {
    border-color: #4299e1;
    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
  }

  .stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin: 20px 0;
  }

  .stat {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px;
    border-radius: 10px;
    text-align: center;
  }

  .stat-value {
    font-size: 1.8rem;
    font-weight: bold;
  }

  .progress-bar {
    width: 100%;
    height: 10px;
    background: #e2e8f0;
    border-radius: 5px;
    overflow: hidden;
    margin: 20px 0;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
    transition: width 0.3s ease;
  }

  .controls {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .btn {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .btn-primary {
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    color: white;
  }

  .btn-secondary {
    background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
    color: white;
  }

  .btn-warning {
    background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
    color: white;
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }

  .game-complete {
    text-align: center;
    padding: 30px;
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    color: white;
    border-radius: 15px;
    margin: 20px 0;
    animation: celebration 0.5s ease;
  }

  .game-over {
    text-align: center;
    padding: 30px;
    background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
    color: white;
    border-radius: 15px;
    margin: 20px 0;
  }

  .help-text {
    margin-top: 15px;
    font-size: 0.9rem;
    opacity: 0.8;
  }

  kbd {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
    color: white;
    display: inline-block;
    font-size: 0.8rem;
    font-family: monospace;
    line-height: 1;
    padding: 2px 6px;
    margin: 0 2px;
  }

  .emoji {
    font-size: 2rem;
    margin: 10px 0;
  }

  @keyframes celebration {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  .text-source-selector {
    background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
    padding: 15px;
    border-radius: 15px;
    color: white;
    margin-top: 30px;
    text-align: center;
    position: relative;
  }

  .text-source-selector.fixed-bottom {
    border-top: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px 15px 0 0;
    margin-top: 50px; /* Increased spacing from above content */
    padding-top: 15px;
    padding-bottom: 18px;
    box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
  }

  .source-label {
    display: block;
    margin-bottom: 10px;
    font-weight: bold;
    font-size: 1rem;
  }

  /* Add more bottom spacing to elements above the selector */
  .stats, .game-complete, .game-over {
    margin-bottom: 30px;
  }

  .source-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin-bottom: 10px;
  }

  .source-btn {
    padding: 8px 15px;
    border-radius: 25px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .source-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
  }

  .source-btn.selected {
    background: white;
    color: #3182ce;
    border-color: white;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }

  .source-info {
    font-size: 0.9rem;
    margin-top: 12px;
    background: rgba(255, 255, 255, 0.1);
    padding: 8px;
    border-radius: 8px;
  }

  .source-info a {
    color: #e2e8f0;
    text-decoration: underline;
    transition: color 0.2s ease;
  }

  .source-info a:hover {
    color: white;
  }
</style>
